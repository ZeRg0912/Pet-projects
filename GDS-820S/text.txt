ChatGPT (беседа № 1):

Приношу извинения за путаницу. Вот обновленный код, который использует асинхронную передачу SCPI команд:

#include <iostream>
#include <Windows.h>

void CALLBACK WriteCompletionRoutine(DWORD dwErrorCode, DWORD dwBytesTransferred, LPOVERLAPPED lpOverlapped) {
    // Пустая функция обратного вызова
}

void CALLBACK ReadCompletionRoutine(DWORD dwErrorCode, DWORD dwBytesTransferred, LPOVERLAPPED lpOverlapped) {
    // Пустая функция обратного вызова
}

int main() {
    HANDLE hComm;
    char portName[] = "COM1";
    DWORD baudRate = CBR_9600; // скорость передачи данных
    DCB dcb = {0};
    OVERLAPPED writeOverlapped = {0};
    OVERLAPPED readOverlapped = {0};

    // Открытие COM-порта
    hComm = CreateFileA(portName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
    if (hComm == INVALID_HANDLE_VALUE) {
        std::cout << "Не удалось открыть COM-порт." << std::endl;
        return 1;
    }

    // Получение текущих настроек порта
    if (!GetCommState(hComm, &dcb)) {
        std::cout << "Не удалось получить настройки COM-порта." << std::endl;
        CloseHandle(hComm);
        return 1;
    }

    // Настройка параметров порта
    dcb.BaudRate = baudRate;
    dcb.ByteSize = 8; // бит данных
    dcb.Parity = NOPARITY; // проверка на четность
    dcb.StopBits = ONESTOPBIT; // количество стоп-бит
    if (!SetCommState(hComm, &dcb)) {
        std::cout << "Не удалось настроить COM-порт." << std::endl;
        CloseHandle(hComm);
        return 1;
    }

    // SCPI команда для установки напряжения в 1 вольт
    const char* setVoltageCommand = "SOURCE:VOLTage:LEVel 1";

    // Отправка SCPI команды установки напряжения
    DWORD bytesWritten;
    writeOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!WriteFileEx(hComm, setVoltageCommand, strlen(setVoltageCommand), &writeOverlapped, WriteCompletionRoutine)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            std::cout << "Не удалось начать отправку данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Ожидание завершения отправки
        if (WaitForSingleObject(writeOverlapped.hEvent, 5000) != WAIT_OBJECT_0) {
            CancelIo(hComm);
            std::cout << "Тайм-аут при отправке данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Получение результата отправки
        if (!GetOverlappedResult(hComm, &writeOverlapped, &bytesWritten, FALSE)) {
            std::cout << "Не удалось получить результат отправки данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }
    }

    // SCPI команда для измерения тока
    const char* measureCurrentCommand = "MEASure:CURRent:DC?";

    // Отправка SCPI команды измерения тока
    if (!WriteFileEx(hComm, measureCurrentCommand, strlen(measureCurrentCommand), &writeOverlapped, WriteCompletionRoutine)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            std::cout << "Не удалось начать отправку данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Ожидание завершения отправки
        if (WaitForSingleObject(writeOverlapped.hEvent, 5000) != WAIT_OBJECT_0) {
            CancelIo(hComm);
            std::cout << "Тайм-аут при отправке данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Получение результата отправки
        if (!GetOverlappedResult(hComm, &writeOverlapped, &bytesWritten, FALSE)) {
            std::cout << "Не удалось получить результат отправки данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }
    }

    // Чтение ответа от Keithley 2400
    char response[256];
    DWORD bytesRead;
    readOverlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!ReadFileEx(hComm, response, sizeof(response) - 1, &readOverlapped, ReadCompletionRoutine)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            std::cout << "Не удалось начать чтение данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Ожидание завершения чтения
        if (WaitForSingleObject(readOverlapped.hEvent, 5000) != WAIT_OBJECT_0) {
            CancelIo(hComm);
            std::cout << "Тайм-аут при чтении данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Получение результата чтения
        if (!GetOverlappedResult(hComm, &readOverlapped, &bytesRead, FALSE)) {
            std::cout << "Не удалось получить результат чтения данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }
    }

    // Добавляем терминирующий символ null в конец строки
    response[bytesRead] = '\0';

    // Вывод ответа
    std::cout << "Ток измеренный Keithley 2400: " << response << std::endl;

    // Закрытие COM-порта
    CloseHandle(hComm);

    return 0;
}

Этот обновленный код снова использует асинхронную передачу SCPI команд. Обратите внимание, что функции обратного вызова WriteCompletionRoutine и ReadCompletionRoutine являются пустыми функциями обратного вызова. Они могут быть использованы для обработки завершения асинхронных операций, если это необходимо.

Проверьте этот обновленный код с использованием асинхронной передачи SCPI команд для установки напряжения и измерения тока с Keithley 2400.

9171 из 16384