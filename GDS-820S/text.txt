ChatGPT (беседа № 1):

Если программа выводит "Не удалось отправить SCPI команду", проблема может быть связана с асинхронной отправкой данных. Мы можем использовать асинхронную передачу данных с помощью функции WriteFileEx и функции обратного вызова CompletionRoutine.

Вот обновленный код, который исправляет эту проблему:

#include <iostream>
#include <Windows.h>

void CALLBACK WriteCompletionRoutine(DWORD dwErrorCode, DWORD dwBytesTransferred, LPOVERLAPPED lpOverlapped) {
    // Пустая функция обратного вызова
}

int main() {
    HANDLE hComm;
    char portName[] = "COM1";
    DWORD baudRate = CBR_9600; // скорость передачи данных
    DCB dcb = {0};

    // Открытие COM-порта
    hComm = CreateFileA(portName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
    if (hComm == INVALID_HANDLE_VALUE) {
        std::cout << "Не удалось открыть COM-порт." << std::endl;
        return 1;
    }

    // Получение текущих настроек порта
    if (!GetCommState(hComm, &dcb)) {
        std::cout << "Не удалось получить настройки COM-порта." << std::endl;
        CloseHandle(hComm);
        return 1;
    }

    // Настройка параметров порта
    dcb.BaudRate = baudRate;
    dcb.ByteSize = 8; // бит данных
    dcb.Parity = NOPARITY; // проверка на четность
    dcb.StopBits = ONESTOPBIT; // количество стоп-бит
    if (!SetCommState(hComm, &dcb)) {
        std::cout << "Не удалось настроить COM-порт." << std::endl;
        CloseHandle(hComm);
        return 1;
    }

    // SCPI команда для получения IDN строки
    const char* scpiCommand = "*IDN?";

    // Отправка SCPI команды
    DWORD bytesWritten;
    OVERLAPPED overlapped = { 0 };
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!WriteFileEx(hComm, scpiCommand, strlen(scpiCommand), &overlapped, WriteCompletionRoutine)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            std::cout << "Не удалось начать отправку данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Ожидание завершения отправки
        if (WaitForSingleObject(overlapped.hEvent, 5000) != WAIT_OBJECT_0) {
            CancelIo(hComm);
            std::cout << "Тайм-аут при отправке данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Получение результата отправки
        if (!GetOverlappedResult(hComm, &overlapped, &bytesWritten, FALSE)) {
            std::cout << "Не удалось получить результат отправки данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }
    }

    // Чтение ответа от Keithley 2400
    char response[256];
    DWORD bytesRead;
    overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!ReadFile(hComm, response, sizeof(response) - 1, &bytesRead, &overlapped)) {
        if (GetLastError() != ERROR_IO_PENDING) {
            std::cout << "Не удалось начать чтение данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Ожидание завершения чтения
        if (WaitForSingleObject(overlapped.hEvent, 5000) != WAIT_OBJECT_0) {
            CancelIo(hComm);
            std::cout << "Тайм-аут при чтении данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }

        // Получение результата чтения
        if (!GetOverlappedResult(hComm, &overlapped, &bytesRead, FALSE)) {
            std::cout << "Не удалось получить результат чтения данных." << std::endl;
            CloseHandle(hComm);
            return 1;
        }
    }

    // Добавляем терминирующий символ null в конец строки
    response[bytesRead] = '\0';

    // Вывод ответа

    std::cout << "IDN строка от Keithley 2400: " << response << std::endl;

    // Закрытие COM-порта
    CloseHandle(hComm);

    return 0;
}

В этом коде мы используем функцию WriteFileEx для асинхронной отправки команды и функцию ReadFile для чтения ответа. Функция обратного вызова WriteCompletionRoutine остается пустой. Проверьте, выведется ли IDN строка с Keithley 2400 после внесения этих изменений.

4351 из 16384